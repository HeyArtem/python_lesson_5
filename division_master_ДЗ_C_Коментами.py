def number_1_1000(n):
    '''

    Функция проверяет полученное число, что бы
    оно нахлдилось в промежутке между 1 и 1000
    :param n: получает число для проверки
    :return: Возвращает вводимое число если оно в промежутке
             м/у 1 и 100 и выдаст None, если число вне заданного промежутка

    '''
    if n in (i for i in range(1, 1001)):
        return(n)
    else:
        return None

print(number_1_1000(1.5))



# 1 проверка числа на простоту (простые числа - это те числа у которых делители единица и они сами)
print('   1 проверка числа на простоту (простые числа - это те числа\n    у которых делители единица и они сами)')

def isPrime(n):
    '''

    Функция получает число, сначала проверяет его через функцию
    def number_1_1000(n), и убедившись, что оно находится в промежутке м/у
    1 и 1000., проверяет, является ли оно простым (простое, делится только
    на 1 и самого себя)

    :param n: получает число, которое нужно проверить на простототу
    :return: 'Простое число' -> если число простое
              'Составное число' -> если число не простое
              'Data error' -> если число не находиться в промежутке м/у 1 и 1000

    '''
    if number_1_1000(n):
        print('значение number_1_1000= ', number_1_1000(n))
        lst = []
        print('lst=', lst)
        for i in range(2, n+1):
            print('i= ', i)
            for j in lst:
                print('j= ', j)
                if i % j ==0:
                    print('значение i после деления на j->', i)
                    print('значение j после деления на i->', j)
                    break
            else:
                lst.append(i)
                print('* Итог шага печатаю \nlst -> ', lst)
        if n in lst:
            return ('Простое число')
        else:
            return ('Составное число')
    else:
        return 'Data error'

print(isPrime(16))



print()
# 2 выводит список всех делителей числа
print('   2 выводит список всех делителей числа: ')

def list_devisor(n):
    if number_1_1000(n):
        print('number_1_1000(n)=', n)
        lst = []
        print(lst)
        for i in (j for j in range(1, n+1)):
            print('i=', i)
            #print('j=', j)
            print('n=', n)
            if n%i ==0:
                lst.append(i)
                print('lst -> ', lst)
        return lst
    else:
        return 'Data error'

print(list_devisor(30))



print()
# 3 выводит самый большой простой делитель числа.
print('   * * *  3 выводит самый большой простой делитель числа.')

def big_devisor(n):
    if number_1_1000(n):
        '''
        
        функция получает число, для того, что бы определить лежит ли это число в заданном диапазоне (от 1 до 1000), 
        проверяет его через функцию number_1_1000(n). После этого создает два списка: lst (список простых чисел и 
        dev(список простых делителей). После этого выводит макимальное число из списка с простыми делителями (lst)
        
        :param n: получает число, у которого нужно найти максимальный делитель 
        :return: -> выводит самый большой простой делитель числа
                'Data error' -> если число не находиться в промежутке м/у 1 и 1000
        
        
        '''
        lst = [] # список простых чисел
        dev = [] # список простых делителей
        for i in range(2, n+1):
            print('í= ', i)
            for j in lst:
                print('j= ', j)
                if i % j ==0:
                    print('lst 1', lst)
                    print('dev 1', dev)
                    break
            else:
                lst.append(i)
                print('lst2= ', lst)
                print('dev2= ', dev)
                if n % i == 0:
                    dev.append(i)
                    print('* lst3 ', lst)
                    print('* dev3 ', dev)
        return max(dev)
    else:
        return 'Data eror'
print(big_devisor(10))









print()
# 4 функция выводит каноническое разложение числа
print('   4 функция выводит каноническое разложение числа')

# Функция состоит из двух частей. Первая часть генерирует список простых чисел и
#   сохраняеи его в lst[]. Дальше запускается вторая часть, которая берет заданное число
#   и циклом делит его каждым участником списка lst, причем, например во втором круге цикл делит не изначально
#   заданное число, а частное полученное от деления в первом круге цикла (от деления на первого участника lst)

def prime_composit(n):

    ''''
    Функция получает число, для того, что бы определить лежит ли это число в заданном диапазоне (от 1 до 1000),
    проверяет его через функцию number_1_1000(n). После это создает сисок dev, где накапливает
    каноническое разложение числа

    :param n: получает число, с которым нужно сделать каноническое разложение
    :return: -> выводит каноническое разложение
            'Data error' -> если число не находиться в промежутке м/у 1 и 1000

    '''
    if number_1_1000(n):
        print('number_1_1000(n) = ', number_1_1000(n))
        lst = []
        for i in range(2, n+1):
            print('lst1 = ', lst)
            print('i= ', i)
            for j in lst:
                print('j= ', j)
                if i % j ==0:
                    break
            else:
                lst.append(i)
                print('lst= ', lst)
        dev = []
        print('dev1', dev)
        for j in lst:
            while n % j == 0:
                print('n = ', n)
                print('j = ', j)
                n=int(n/j)
                dev.append(j)
                print('dev= ', dev)
        return dev
    else:
        return 'Data eror'
print(prime_composit(20))









print()
# 5 функция выводит самый большой делитель (не обязательно простой) числа.
print('    5 функция выводит самый большой делитель (не обязательно простой) числа.')

def very_dig_divisor(n):
    ''''
    Функция получает число, сначало определяет лежит ли это число в заданном диапазоне (от 1 до 1000),
    проверяет его через функцию number_1_1000(n). После этого создает список dev[], и складывает
    в него все простые делители. После этого выводит результат - максимального по значению участника списка lst[]

    :param n: получает число, у которого нужно найти максимальный делитель
    :return: -> выводит максимальный простой делитель
            'Data error' -> если число не находиться в промежутке м/у 1 и 1000



    '''
    if number_1_1000(n):
        dev = []
        for i in range(1, n):
            print('i= ', i)
            print('n= ', n)
            if n % i == 0:
                dev.append(i)
                print('*dev = ', dev)
        return max(dev)
    else: 'Data eror'

print(very_dig_divisor(70))