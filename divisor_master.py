# Необходимо реализовать модуль divisor_master. Все функции модуля принимают
# на вход натуральные числа от 1 до 1000. Модуль содержит функции:





def number_1_1000(n):
    '''

        Функция проверяет полученное число, что бы
        оно нахлдилось в промежутке между 1 и 1000
        :param n: получает число для проверки
        :return: Возвращает вводимое число если оно в промежутке
                 м/у 1 и 100 и выдаст None, если число вне заданного промежутка

    '''
    if n in (i for i in range(1, 1001)):
        return(n)
    else:
        return None

print(number_1_1000(1.5))


print()
# 1 проверка числа на простоту (простые числа - это те числа у которых делители единица и они сами)
print('   1 проверка числа на простоту (простые числа - это те числа\n    у которых делители единица и они сами)')

def isPrime(n):
    '''

    Функция получает число, сначала проверяет его через функцию
    def number_1_1000(n), и убедившись, что оно находится в промежутке м/у
    1 и 1000., проверяет, является ли оно простым (простое, делится только
    на 1 и самого себя)

    :param n: получает число, которое нужно проверить на простототу
    :return: 'Простое число' -> если число простое
              'Составное число' -> если число не простое
              'Data error' -> если число не находиться в промежутке м/у 1 и 1000

    '''
    if number_1_1000(n):
        lst = []
        for i in range(2, n+1):
            for j in lst:
                if i % j ==0:
                    break
            else:
                lst.append(i)
        if n in lst:
            return ('Простое число')
        else:
            return ('Составное число')
    else:
        return 'Data error'

print(isPrime(7))

print()
# 2 выводит список всех делителей числа
print('   2 выводит список всех делителей числа: ')


def list_devisor(n):
    if number_1_1000(n):
        lst = []
        for i in (j for j in range(1, n + 1)):
            if n % i == 0:
                lst.append(i)
        return lst
    else:
        return 'Data error'


print(list_devisor(30))


print()
# 3 выводит самый большой простой делитель числа.
print('   * * *  3 выводит самый большой простой делитель числа.')


def big_devisor(n):
    if number_1_1000(n):
        '''

        функция получает число, для того, что бы определить лежит ли это число в заданном диапазоне (от 1 до 1000), 
        проверяет его через функцию number_1_1000(n). После этого создает два списка: lst (список простых чисел и 
        dev(список простых делителей). После этого выводит макимальное число из списка с простыми делителями (lst)

        :param n: получает число, у которого нужно найти максимальный делитель 
        :return: -> выводит самый большой простой делитель числа
                'Data error' -> если число не находиться в промежутке м/у 1 и 1000


        '''
        lst = []  # список простых чисел
        dev = []  # список простых делителей
        for i in range(2, n + 1):
            for j in lst:
                if i % j == 0:
                    break
            else:
                lst.append(i)
                if n % i == 0:
                    dev.append(i)
        return max(dev)
    else:
        return 'Data eror'


print(big_devisor(10))

print()
# 4 функция выводит каноническое разложение числа
print('   4 функция выводит каноническое разложение числа')



def prime_composit(n):
    ''''
    Функция получает число, для того, что бы определить лежит ли это число в заданном диапазоне (от 1 до 1000),
    проверяет его через функцию number_1_1000(n). После это создает сисок dev, где накапливает
    каноническое разложение числа

    :param n: получает число, с которым нужно сделать каноническое разложение
    :return: -> выводит каноническое разложение
            'Data error' -> если число не находиться в промежутке м/у 1 и 1000

    '''
    if number_1_1000(n):
        lst = []
        for i in range(2, n + 1):
            for j in lst:
                if i % j == 0:
                    break
            else:
                lst.append(i)
        dev = []
        for j in lst:
            while n % j == 0:
                n = int(n / j)
                dev.append(j)
        return dev
    else:
        return 'Data eror'


print(prime_composit(20))

print()
# 5 функция выводит самый большой делитель (не обязательно простой) числа.
print('    5 функция выводит самый большой делитель (не обязательно простой) числа.')


def very_dig_divisor(n):
    ''''
    Функция получает число, сначало определяет лежит ли это число в заданном диапазоне (от 1 до 1000),
    проверяет его через функцию number_1_1000(n). После этого создает список dev[], и складывает
    в него все простые делители. После этого выводит результат - максимального по значению участника списка lst[]

    :param n: получает число, у которого нужно найти максимальный делитель
    :return: -> выводит максимальный простой делитель
            'Data error' -> если число не находиться в промежутке м/у 1 и 1000



    '''
    if number_1_1000(n):
        dev = []
        for i in range(1, n):
            if n % i == 0:
                dev.append(i)
        return max(dev)
    else:
        'Data eror'


print(very_dig_divisor(70))







